local http1 = (function() local function vtable_entry(instance, index, type) return ffi.cast(type, (ffi.cast("void***", instance)[0])[index]) end local function vtable_thunk(index, typestring) local t = ffi.typeof(typestring) return function(instance, ...) assert(instance ~= nil) if instance then return vtable_entry(instance, index, t)(instance, ...) end end end local function vtable_bind(module, interface, index, typestring) local instance = create_interface(module, interface) or error("invalid interface") local fnptr = vtable_entry(instance, index, ffi.typeof(typestring)) or error("invalid vtable") return function(...) return fnptr(instance, ...) end end local cache = setmetatable({}, {__mode = "v"}) local inline_comment = "^%s*//[^\n]*\n()" local multi_line_comment = "^%s*/%*.-*/%s*()" local enumpat = "^(%s*([%w_][%a_]*)%s*(=?)%s*([x%x]*)%s*())" local function enum(defs) local cached = cache[defs] if cached then return cached end local N = 0 local pos = 1 local len = #defs local res = {} local coma = false while true do if pos == len + 1 then break end if pos > len + 1 then error("LARGER: "..pos.." "..len) end local p = defs:match(inline_comment, pos) or defs:match(multi_line_comment, pos) if not p then if coma then p = defs:match("^%s*,%s*()", pos) if not p then error"malformed enum: coma expected" end coma = false else local chunk, name, eq, value chunk, name, eq, value, p = defs:match(enumpat, pos) if not p then error("malformed enum definition") end if value ~= "" then assert(value:find"^%-?%d+$" or value:find"0x%x+", "badly formed number "..value.." in enum") N = tonumber(value) end local i = N N = N + 1 if eq == "" and value == "" or eq == "=" and value ~= "" then res[#res+1] = "  static const int "..name.." = "..i..";" else error("badly formed enum: " .. chunk) end coma = true end end pos = p end res = ffi.new("struct{ \n"..table.concat(res, "\n").."\n}") cache[defs] = res return res end local register_call_result, register_callback, steam_client_context do if not pcall(ffi.sizeof, "SteamAPICall_t") then ffi.cdef[[ typedef uint64_t SteamAPICall_t; struct SteamAPI_callback_base_vtbl { void(__thiscall *run1)(struct SteamAPI_callback_base *, void *, bool, uint64_t); void(__thiscall *run2)(struct SteamAPI_callback_base *, void *); int(__thiscall *get_size)(struct SteamAPI_callback_base *); }; struct SteamAPI_callback_base { struct SteamAPI_callback_base_vtbl *vtbl; uint8_t flags; int id; uint64_t api_call_handle; struct SteamAPI_callback_base_vtbl vtbl_storage[1]; }; ]] end local ESteamAPICallFailure = { [-1] = "No failure", [0]  = "Steam gone", [1]  = "Network failure", [2]  = "Invalid handle", [3]  = "Mismatched callback" } local SteamAPI_RegisterCallResult, SteamAPI_UnregisterCallResult local SteamAPI_RegisterCallback, SteamAPI_UnregisterCallback local GetAPICallFailureReason local callback_base = ffi.typeof("struct SteamAPI_callback_base") local sizeof_callback_base = ffi.sizeof(callback_base) local callback_base_array = ffi.typeof("struct SteamAPI_callback_base[1]") local callback_base_ptr = ffi.typeof("struct SteamAPI_callback_base*") local uintptr_t = ffi.typeof("uintptr_t") local api_call_handlers = {} local pending_call_results = {} local registered_callbacks = {} local function pointer_key(p) return tostring(tonumber(ffi.cast(uintptr_t, p))) end local function callback_base_run_common(self, param, io_failure) if io_failure then io_failure = ESteamAPICallFailure[GetAPICallFailureReason(self.api_call_handle)] or "Unknown error" end self.api_call_handle = 0 xpcall(function() local key = pointer_key(self) local handler = api_call_handlers[key] if handler ~= nil then xpcall(handler, client.log, param, io_failure) end if pending_call_results[key] ~= nil then api_call_handlers[key] = nil pending_call_results[key] = nil end end, client.log) end local function callback_base_run1(self, param, io_failure, api_call_handle) if api_call_handle == self.api_call_handle then callback_base_run_common(self, param, io_failure) end end local function callback_base_run2(self, param) callback_base_run_common(self, param, false) end local function callback_base_get_size(self) return sizeof_callback_base end local function call_result_cancel(self) if self.api_call_handle ~= 0 then SteamAPI_UnregisterCallResult(self, self.api_call_handle) self.api_call_handle = 0 local key = pointer_key(self) api_call_handlers[key] = nil pending_call_results[key] = nil end end pcall(ffi.metatype, callback_base, { __gc = call_result_cancel, __index = { cancel = call_result_cancel } }) local callback_base_run1_ct = ffi.cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *, bool, uint64_t)", callback_base_run1) local callback_base_run2_ct = ffi.cast("void(__thiscall *)(struct SteamAPI_callback_base *, void *)", callback_base_run2) local callback_base_get_size_ct = ffi.cast("int(__thiscall *)(struct SteamAPI_callback_base *)", callback_base_get_size) function register_call_result(api_call_handle, handler, id) assert(api_call_handle ~= 0) local instance_storage = callback_base_array() local instance = ffi.cast(callback_base_ptr, instance_storage) instance.vtbl_storage[0].run1 = callback_base_run1_ct instance.vtbl_storage[0].run2 = callback_base_run2_ct instance.vtbl_storage[0].get_size = callback_base_get_size_ct instance.vtbl = instance.vtbl_storage instance.api_call_handle = api_call_handle instance.id = id local key = pointer_key(instance) api_call_handlers[key] = handler pending_call_results[key] = instance_storage SteamAPI_RegisterCallResult(instance, api_call_handle) return instance end function register_callback(id, handler) assert(registered_callbacks[id] == nil) local instance_storage = callback_base_array() local instance = ffi.cast(callback_base_ptr, instance_storage) instance.vtbl_storage[0].run1 = callback_base_run1_ct instance.vtbl_storage[0].run2 = callback_base_run2_ct instance.vtbl_storage[0].get_size = callback_base_get_size_ct instance.vtbl = instance.vtbl_storage instance.api_call_handle = 0 instance.id = id local key = pointer_key(instance) api_call_handlers[key] = handler registered_callbacks[id] = instance_storage SteamAPI_RegisterCallback(instance, id) end local function find_sig(mdlname, pattern, typename, offset, deref_count) local raw_match = memory.find_pattern(mdlname, pattern) or error("signature not found", 2) local match = ffi.cast("uintptr_t", raw_match) if offset ~= nil and offset ~= 0 then match = match + offset end if deref_count ~= nil then for i = 1, deref_count do match = ffi.cast("uintptr_t*", match)[0] if match == nil then return error("signature not found") end end end return ffi.cast(typename, match) end SteamAPI_RegisterCallResult = find_sig("steam_api.dll", "55 8B EC 83 3D ?? ?? ?? ?? ?? 7E 0D 68 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 5D C3 FF 75 10", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)") SteamAPI_UnregisterCallResult = find_sig("steam_api.dll", "55 8B EC FF 75 10 FF 75 0C", "void(__cdecl*)(struct SteamAPI_callback_base *, uint64_t)") SteamAPI_RegisterCallback = find_sig("steam_api.dll", "55 8B EC 83 3D ?? ?? ?? ?? ?? 7E 0D 68 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 5D C3 C7 05", "void(__cdecl*)(struct SteamAPI_callback_base *, int)") SteamAPI_UnregisterCallback = find_sig("steam_api.dll", "55 8B EC 83 EC 08 80 3D", "void(__cdecl*)(struct SteamAPI_callback_base *)") steam_client_context = find_sig( "client.dll", "B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 3D ?? ?? ?? ?? ?? 0F 84", "uintptr_t", 1, 1 ) local steamutils = ffi.cast("uintptr_t*", steam_client_context)[3] local native_GetAPICallFailureReason = vtable_entry(steamutils, 12, "int(__thiscall*)(void*, SteamAPICall_t)") function GetAPICallFailureReason(handle) return native_GetAPICallFailureReason(steamutils, handle) end callbacks.add(e_callbacks.SHUTDOWN, function() for key, value in pairs(pending_call_results) do local instance = ffi.cast(callback_base_ptr, value) call_result_cancel(instance) end for key, value in pairs(registered_callbacks) do local instance = ffi.cast(callback_base_ptr, value) SteamAPI_UnregisterCallback(instance) end end) end if not pcall(ffi.sizeof, "http_HTTPRequestHandle") then ffi.cdef([[ typedef uint32_t http_HTTPRequestHandle; typedef uint32_t http_HTTPCookieContainerHandle; enum http_EHTTPMethod { k_EHTTPMethodInvalid, k_EHTTPMethodGET, k_EHTTPMethodHEAD, k_EHTTPMethodPOST, k_EHTTPMethodPUT, k_EHTTPMethodDELETE, k_EHTTPMethodOPTIONS, k_EHTTPMethodPATCH, }; struct http_ISteamHTTPVtbl { http_HTTPRequestHandle(__thiscall *CreateHTTPRequest)(uintptr_t, enum http_EHTTPMethod, const char *); bool(__thiscall *SetHTTPRequestContextValue)(uintptr_t, http_HTTPRequestHandle, uint64_t); bool(__thiscall *SetHTTPRequestNetworkActivityTimeout)(uintptr_t, http_HTTPRequestHandle, uint32_t); bool(__thiscall *SetHTTPRequestHeaderValue)(uintptr_t, http_HTTPRequestHandle, const char *, const char *); bool(__thiscall *SetHTTPRequestGetOrPostParameter)(uintptr_t, http_HTTPRequestHandle, const char *, const char *); bool(__thiscall *SendHTTPRequest)(uintptr_t, http_HTTPRequestHandle, SteamAPICall_t *); bool(__thiscall *SendHTTPRequestAndStreamResponse)(uintptr_t, http_HTTPRequestHandle, SteamAPICall_t *); bool(__thiscall *DeferHTTPRequest)(uintptr_t, http_HTTPRequestHandle); bool(__thiscall *PrioritizeHTTPRequest)(uintptr_t, http_HTTPRequestHandle); bool(__thiscall *GetHTTPResponseHeaderSize)(uintptr_t, http_HTTPRequestHandle, const char *, uint32_t *); bool(__thiscall *GetHTTPResponseHeaderValue)(uintptr_t, http_HTTPRequestHandle, const char *, uint8_t *, uint32_t); bool(__thiscall *GetHTTPResponseBodySize)(uintptr_t, http_HTTPRequestHandle, uint32_t *); bool(__thiscall *GetHTTPResponseBodyData)(uintptr_t, http_HTTPRequestHandle, uint8_t *, uint32_t); bool(__thiscall *GetHTTPStreamingResponseBodyData)(uintptr_t, http_HTTPRequestHandle, uint32_t, uint8_t *, uint32_t); bool(__thiscall *ReleaseHTTPRequest)(uintptr_t, http_HTTPRequestHandle); bool(__thiscall *GetHTTPDownloadProgressPct)(uintptr_t, http_HTTPRequestHandle, float *); bool(__thiscall *SetHTTPRequestRawPostBody)(uintptr_t, http_HTTPRequestHandle, const char *, uint8_t *, uint32_t); http_HTTPCookieContainerHandle(__thiscall *CreateCookieContainer)(uintptr_t, bool); bool(__thiscall *ReleaseCookieContainer)(uintptr_t, http_HTTPCookieContainerHandle); bool(__thiscall *SetCookie)(uintptr_t, http_HTTPCookieContainerHandle, const char *, const char *, const char *); bool(__thiscall *SetHTTPRequestCookieContainer)(uintptr_t, http_HTTPRequestHandle, http_HTTPCookieContainerHandle); bool(__thiscall *SetHTTPRequestUserAgentInfo)(uintptr_t, http_HTTPRequestHandle, const char *); bool(__thiscall *SetHTTPRequestRequiresVerifiedCertificate)(uintptr_t, http_HTTPRequestHandle, bool); bool(__thiscall *SetHTTPRequestAbsoluteTimeoutMS)(uintptr_t, http_HTTPRequestHandle, uint32_t); bool(__thiscall *GetHTTPRequestWasTimedOut)(uintptr_t, http_HTTPRequestHandle, bool *pbWasTimedOut); }; ]]) end local http_EHTTPMethod = enum[[ k_EHTTPMethodInvalid, k_EHTTPMethodGET, k_EHTTPMethodHEAD, k_EHTTPMethodPOST, k_EHTTPMethodPUT, k_EHTTPMethodDELETE, k_EHTTPMethodOPTIONS, k_EHTTPMethodPATCH, ]] local method_name_to_enum = { get = http_EHTTPMethod.k_EHTTPMethodGET, head = http_EHTTPMethod.k_EHTTPMethodHEAD, post = http_EHTTPMethod.k_EHTTPMethodPOST, put = http_EHTTPMethod.k_EHTTPMethodPUT, delete = http_EHTTPMethod.k_EHTTPMethodDELETE, options = http_EHTTPMethod.k_EHTTPMethodOPTIONS, patch = http_EHTTPMethod.k_EHTTPMethodPATCH, } local status_code_to_message = { [100]="Continue",[101]="Switching Protocols",[102]="Processing",[200]="OK",[201]="Created",[202]="Accepted",[203]="Non-Authoritative Information",[204]="No Content",[205]="Reset Content",[206]="Partial Content",[207]="Multi-Status", [208]="Already Reported",[250]="Low on Storage Space",[226]="IM Used",[300]="Multiple Choices",[301]="Moved Permanently",[302]="Found",[303]="See Other",[304]="Not Modified",[305]="Use Proxy",[306]="Switch Proxy", [307]="Temporary Redirect",[308]="Permanent Redirect",[400]="Bad Request",[401]="Unauthorized",[402]="Payment Required",[403]="Forbidden",[404]="Not Found",[405]="Method Not Allowed",[406]="Not Acceptable",[407]="Proxy Authentication Required", [408]="Request Timeout",[409]="Conflict",[410]="Gone",[411]="Length Required",[412]="Precondition Failed",[413]="Request Entity Too Large",[414]="Request-URI Too Long",[415]="Unsupported Media Type",[416]="Requested Range Not Satisfiable", [417]="Expectation Failed",[418]="I'm a teapot",[420]="Enhance Your Calm",[422]="Unprocessable Entity",[423]="Locked",[424]="Failed Dependency",[424]="Method Failure",[425]="Unordered Collection",[426]="Upgrade Required",[428]="Precondition Required", [429]="Too Many Requests",[431]="Request Header Fields Too Large",[444]="No Response",[449]="Retry With",[450]="Blocked by Windows Parental Controls",[451]="Parameter Not Understood",[451]="Unavailable For Legal Reasons",[451]="Redirect", [452]="Conference Not Found",[453]="Not Enough Bandwidth",[454]="Session Not Found",[455]="Method Not Valid in This State",[456]="Header Field Not Valid for Resource",[457]="Invalid Range",[458]="Parameter Is Read-Only",[459]="Aggregate Operation Not Allowed", [460]="Only Aggregate Operation Allowed",[461]="Unsupported Transport",[462]="Destination Unreachable",[494]="Request Header Too Large",[495]="Cert Error",[496]="No Cert",[497]="HTTP to HTTPS",[499]="Client Closed Request",[500]="Internal Server Error", [501]="Not Implemented",[502]="Bad Gateway",[503]="Service Unavailable",[504]="Gateway Timeout",[505]="HTTP Version Not Supported",[506]="Variant Also Negotiates",[507]="Insufficient Storage",[508]="Loop Detected",[509]="Bandwidth Limit Exceeded", [510]="Not Extended",[511]="Network Authentication Required",[551]="Option not supported",[598]="Network read timeout error",[599]="Network connect timeout error" } local single_allowed_keys = {"params", "body", "json"} local CALLBACK_HTTPRequestCompleted = 2101 local CALLBACK_HTTPRequestHeadersReceived = 2102 local CALLBACK_HTTPRequestDataReceived = 2103 local function find_isteamhttp() local steamhttp = ffi.cast("uintptr_t*", steam_client_context)[12] if steamhttp == 0 or steamhttp == nil then return error("find_isteamhttp failed") end local vmt = ffi.cast("struct http_ISteamHTTPVtbl**", steamhttp)[0] if vmt == 0 or vmt == nil then return error("find_isteamhttp failed") end return steamhttp, vmt end local function func_bind(func, arg) return function(...) return func(arg, ...) end end local HTTPRequestCompleted_t_ptr = ffi.typeof[[ struct { http_HTTPRequestHandle m_hRequest; uint64_t m_ulContextValue; bool m_bRequestSuccessful; int m_eStatusCode; uint32_t m_unBodySize; } * ]] local HTTPRequestHeadersReceived_t_ptr = ffi.typeof[[ struct { http_HTTPRequestHandle m_hRequest; uint64_t m_ulContextValue; } * ]] local HTTPRequestDataReceived_t_ptr = ffi.typeof[[ struct { http_HTTPRequestHandle m_hRequest; uint64_t m_ulContextValue; uint32_t m_cOffset; uint32_t m_cBytesReceived; } * ]] local CookieContainerHandle_t = ffi.typeof[[ struct { http_HTTPCookieContainerHandle m_hCookieContainer; } ]] local SteamAPICall_t_arr = ffi.typeof("SteamAPICall_t[1]") local char_ptr = ffi.typeof("const char[?]") local unit8_ptr = ffi.typeof("uint8_t[?]") local uint_ptr = ffi.typeof("unsigned int[?]") local bool_ptr = ffi.typeof("bool[1]") local float_ptr = ffi.typeof("float[1]") local steam_http, steam_http_vtable = find_isteamhttp() local native_CreateHTTPRequest = func_bind(steam_http_vtable.CreateHTTPRequest, steam_http) local native_SetHTTPRequestContextValue = func_bind(steam_http_vtable.SetHTTPRequestContextValue, steam_http) local native_SetHTTPRequestNetworkActivityTimeout = func_bind(steam_http_vtable.SetHTTPRequestNetworkActivityTimeout, steam_http) local native_SetHTTPRequestHeaderValue = func_bind(steam_http_vtable.SetHTTPRequestHeaderValue, steam_http) local native_SetHTTPRequestGetOrPostParameter = func_bind(steam_http_vtable.SetHTTPRequestGetOrPostParameter, steam_http) local native_SendHTTPRequest = func_bind(steam_http_vtable.SendHTTPRequest, steam_http) local native_SendHTTPRequestAndStreamResponse = func_bind(steam_http_vtable.SendHTTPRequestAndStreamResponse, steam_http) local native_DeferHTTPRequest = func_bind(steam_http_vtable.DeferHTTPRequest, steam_http) local native_PrioritizeHTTPRequest = func_bind(steam_http_vtable.PrioritizeHTTPRequest, steam_http) local native_GetHTTPResponseHeaderSize = func_bind(steam_http_vtable.GetHTTPResponseHeaderSize, steam_http) local native_GetHTTPResponseHeaderValue = func_bind(steam_http_vtable.GetHTTPResponseHeaderValue, steam_http) local native_GetHTTPResponseBodySize = func_bind(steam_http_vtable.GetHTTPResponseBodySize, steam_http) local native_GetHTTPResponseBodyData = func_bind(steam_http_vtable.GetHTTPResponseBodyData, steam_http) local native_GetHTTPStreamingResponseBodyData = func_bind(steam_http_vtable.GetHTTPStreamingResponseBodyData, steam_http) local native_ReleaseHTTPRequest = func_bind(steam_http_vtable.ReleaseHTTPRequest, steam_http) local native_GetHTTPDownloadProgressPct = func_bind(steam_http_vtable.GetHTTPDownloadProgressPct, steam_http) local native_SetHTTPRequestRawPostBody = func_bind(steam_http_vtable.SetHTTPRequestRawPostBody, steam_http) local native_CreateCookieContainer = func_bind(steam_http_vtable.CreateCookieContainer, steam_http) local native_ReleaseCookieContainer = func_bind(steam_http_vtable.ReleaseCookieContainer, steam_http) local native_SetCookie = func_bind(steam_http_vtable.SetCookie, steam_http) local native_SetHTTPRequestCookieContainer = func_bind(steam_http_vtable.SetHTTPRequestCookieContainer, steam_http) local native_SetHTTPRequestUserAgentInfo = func_bind(steam_http_vtable.SetHTTPRequestUserAgentInfo, steam_http) local native_SetHTTPRequestRequiresVerifiedCertificate = func_bind(steam_http_vtable.SetHTTPRequestRequiresVerifiedCertificate, steam_http) local native_SetHTTPRequestAbsoluteTimeoutMS = func_bind(steam_http_vtable.SetHTTPRequestAbsoluteTimeoutMS, steam_http) local native_GetHTTPRequestWasTimedOut = func_bind(steam_http_vtable.GetHTTPRequestWasTimedOut, steam_http) local completed_callbacks, is_in_callback = {}, false local headers_received_callback_registered, headers_received_callbacks = false, {} local data_received_callback_registered, data_received_callbacks = false, {} local cookie_containers = setmetatable({}, {__mode = "k"}) local headers_request_handles, request_handles_headers = setmetatable({}, {__mode = "k"}), setmetatable({}, {__mode = "v"}) local pending_requests = {} local response_headers_mt = { __index = function(req_key, name) local req = headers_request_handles[req_key] if req == nil then return end name = tostring(name) if req.m_hRequest ~= 0 then local header_size = uint_ptr(1) if native_GetHTTPResponseHeaderSize(req.m_hRequest, name, header_size) then if header_size ~= nil then header_size = header_size[0] if header_size < 0 then return end local buffer = unit8_ptr(header_size) if native_GetHTTPResponseHeaderValue(req.m_hRequest, name, buffer, header_size) then req_key[name] = ffi.string(buffer, header_size-1) return req_key[name] end end end end end, __metatable = false } local cookie_container_mt = { __index = { set_cookie = function(handle_key, host, url, name, value) local handle = cookie_containers[handle_key] if handle == nil or handle.m_hCookieContainer == 0 then return end native_SetCookie(handle.m_hCookieContainer, host, url, tostring(name) .. "=" .. tostring(value)) end }, __metatable = false } local function cookie_container_gc(handle) if handle.m_hCookieContainer ~= 0 then native_ReleaseCookieContainer(handle.m_hCookieContainer) handle.m_hCookieContainer = 0 end end local function http_request_gc(req) if req.m_hRequest ~= 0 then native_ReleaseHTTPRequest(req.m_hRequest) req.m_hRequest = 0 end end local function http_request_error(req_handle, ...) native_ReleaseHTTPRequest(req_handle) return error(...) end local function http_request_callback_common(req, callback, successful, data, ...) local headers = request_handles_headers[req.m_hRequest] if headers == nil then headers = setmetatable({}, response_headers_mt) request_handles_headers[req.m_hRequest] = headers end headers_request_handles[headers] = req data.headers = headers is_in_callback = true xpcall(callback, client.log, successful, data, ...) is_in_callback = false end local function http_request_completed(param, io_failure) if param == nil then return end local req = ffi.cast(HTTPRequestCompleted_t_ptr, param) if req.m_hRequest ~= 0 then local callback = completed_callbacks[req.m_hRequest] if callback ~= nil then completed_callbacks[req.m_hRequest] = nil data_received_callbacks[req.m_hRequest] = nil headers_received_callbacks[req.m_hRequest] = nil if callback then local successful = io_failure == false and req.m_bRequestSuccessful local status = req.m_eStatusCode local response = { status = status } local body_size = req.m_unBodySize if successful and body_size > 0 then local buffer = unit8_ptr(body_size) if native_GetHTTPResponseBodyData(req.m_hRequest, buffer, body_size) then response.body = ffi.string(buffer, body_size) end elseif not req.m_bRequestSuccessful then local timed_out = bool_ptr() native_GetHTTPRequestWasTimedOut(req.m_hRequest, timed_out) response.timed_out = timed_out ~= nil and timed_out[0] == true end if status > 0 then response.status_message = status_code_to_message[status] or "Unknown status" elseif io_failure then response.status_message = string.format("IO Failure: %s", io_failure) else response.status_message = response.timed_out and "Timed out" or "Unknown error" end http_request_callback_common(req, callback, successful, response) end http_request_gc(req) end end end local function http_request_headers_received(param, io_failure) if param == nil then return end local req = ffi.cast(HTTPRequestHeadersReceived_t_ptr, param) if req.m_hRequest ~= 0 then local callback = headers_received_callbacks[req.m_hRequest] if callback then http_request_callback_common(req, callback, io_failure == false, {}) end end end local function http_request_data_received(param, io_failure) if param == nil then return end local req = ffi.cast(HTTPRequestDataReceived_t_ptr, param) if req.m_hRequest ~= 0 then local callback = data_received_callbacks[req.m_hRequest] if data_received_callbacks[req.m_hRequest] then local data = {} local download_percentage_prt = float_ptr() if native_GetHTTPDownloadProgressPct(req.m_hRequest, download_percentage_prt) then data.download_progress = tonumber(download_percentage_prt[0]) end local buffer = unit8_ptr(req.m_cBytesReceived) if native_GetHTTPStreamingResponseBodyData(req.m_hRequest, req.m_cOffset, buffer, req.m_cBytesReceived) then data.body = ffi.string(buffer, req.m_cBytesReceived) end http_request_callback_common(req, callback, io_failure == false, data) end end end local function http_request_new(method, url, options, callbacks) if type(options) == "function" and callbacks == nil then callbacks = options options = {} end options = options or {} local method = method_name_to_enum[string.lower(tostring(method))] if method == nil then return error("invalid HTTP method") end if type(url) ~= "string" then return error("URL has to be a string") end local completed_callback, headers_received_callback, data_received_callback if type(callbacks) == "function" then completed_callback = callbacks elseif type(callbacks) == "table" then completed_callback = callbacks.completed or callbacks.complete headers_received_callback = callbacks.headers_received or callbacks.headers data_received_callback = callbacks.data_received or callbacks.data if completed_callback ~= nil and type(completed_callback) ~= "function" then return error("callbacks.completed callback has to be a function") elseif headers_received_callback ~= nil and type(headers_received_callback) ~= "function" then return error("callbacks.headers_received callback has to be a function") elseif data_received_callback ~= nil and type(data_received_callback) ~= "function" then return error("callbacks.data_received callback has to be a function") end else return error("callbacks has to be a function or table") end local req_handle = native_CreateHTTPRequest(method, url) if req_handle == 0 then return error("Failed to create HTTP request") end local set_one = false for i, key in ipairs(single_allowed_keys) do if options[key] ~= nil then if set_one then return error("can only set options.params, options.body or options.json") else set_one = true end end end local json_body if options.json ~= nil then local success success, json_body = pcall(json.encode, options.json) if not success then return error("options.json is invalid: " .. json_body) end end local network_timeout = options.network_timeout if network_timeout == nil then network_timeout = 10 end if type(network_timeout) == "number" and network_timeout > 0 then if not native_SetHTTPRequestNetworkActivityTimeout(req_handle, network_timeout) then return http_request_error(req_handle, "failed to set network_timeout") end elseif network_timeout ~= nil then return http_request_error(req_handle, "options.network_timeout has to be of type number and greater than 0") end local absolute_timeout = options.absolute_timeout if absolute_timeout == nil then absolute_timeout = 30 end if type(absolute_timeout) == "number" and absolute_timeout > 0 then if not native_SetHTTPRequestAbsoluteTimeoutMS(req_handle, absolute_timeout*1000) then return http_request_error(req_handle, "failed to set absolute_timeout") end elseif absolute_timeout ~= nil then return http_request_error(req_handle, "options.absolute_timeout has to be of type number and greater than 0") end local content_type = json_body ~= nil and "application/json" or "text/plain" local authorization_set local headers = options.headers if type(headers) == "table" then for name, value in pairs(headers) do name = tostring(name) value = tostring(value) local name_lower = string.lower(name) if name_lower == "content-type" then content_type = value elseif name_lower == "authorization" then authorization_set = true end if not native_SetHTTPRequestHeaderValue(req_handle, name, value) then return http_request_error(req_handle, "failed to set header " .. name) end end elseif headers ~= nil then return http_request_error(req_handle, "options.headers has to be of type table") end local authorization = options.authorization if type(authorization) == "table" then if authorization_set then return http_request_error(req_handle, "Cannot set both options.authorization and the 'Authorization' header.") end local username, password = authorization[1], authorization[2] local header_value = string_format("Basic %s", base64.encode(string.format("%s:%s", tostring(username), tostring(password)), "base64")) if not native_SetHTTPRequestHeaderValue(req_handle, "Authorization", header_value) then return http_request_error(req_handle, "failed to apply options.authorization") end elseif authorization ~= nil then return http_request_error(req_handle, "options.authorization has to be of type table") end local body = json_body or options.body if type(body) == "string" then local len = string.len(body) if not native_SetHTTPRequestRawPostBody(req_handle, content_type, ffi.cast("unsigned char*", body), len) then return http_request_error(req_handle, "failed to set post body") end elseif body ~= nil then return http_request_error(req_handle, "options.body has to be of type string") end local params = options.params if type(params) == "table" then for name, value in pairs(params) do name = tostring(name) if not native_SetHTTPRequestGetOrPostParameter(req_handle, name, tostring(value)) then return http_request_error(req_handle, "failed to set parameter " .. name) end end elseif params ~= nil then return http_request_error(req_handle, "options.params has to be of type table") end local require_ssl = options.require_ssl if type(require_ssl) == "boolean" then if not native_SetHTTPRequestRequiresVerifiedCertificate(req_handle, require_ssl == true) then return http_request_error(req_handle, "failed to set require_ssl") end elseif require_ssl ~= nil then return http_request_error(req_handle, "options.require_ssl has to be of type boolean") end local user_agent_info = options.user_agent_info if type(user_agent_info) == "string" then if not native_SetHTTPRequestUserAgentInfo(req_handle, tostring(user_agent_info)) then return http_request_error(req_handle, "failed to set user_agent_info") end elseif user_agent_info ~= nil then return http_request_error(req_handle, "options.user_agent_info has to be of type string") end local cookie_container = options.cookie_container if type(cookie_container) == "table" then local handle = cookie_containers[cookie_container] if handle ~= nil and handle.m_hCookieContainer ~= 0 then if not native_SetHTTPRequestCookieContainer(req_handle, handle.m_hCookieContainer) then return http_request_error(req_handle, "failed to set user_agent_info") end else return http_request_error(req_handle, "options.cookie_container has to a valid cookie container") end elseif cookie_container ~= nil then return http_request_error(req_handle, "options.cookie_container has to a valid cookie container") end local send_func = native_SendHTTPRequest local stream_response = options.stream_response if type(stream_response) == "boolean" then if stream_response then send_func = native_SendHTTPRequestAndStreamResponse if completed_callback == nil and headers_received_callback == nil and data_received_callback == nil then return http_request_error(req_handle, "a 'completed', 'headers_received' or 'data_received' callback is required") end else if completed_callback == nil then return http_request_error(req_handle, "'completed' callback has to be set for non-streamed requests") elseif headers_received_callback ~= nil or data_received_callback ~= nil then return http_request_error(req_handle, "non-streamed requests only support 'completed' callbacks") end end elseif stream_response ~= nil then return http_request_error(req_handle, "options.stream_response has to be of type boolean") end if headers_received_callback ~= nil or data_received_callback ~= nil then headers_received_callbacks[req_handle] = headers_received_callback or false if headers_received_callback ~= nil then if not headers_received_callback_registered then register_callback(CALLBACK_HTTPRequestHeadersReceived, http_request_headers_received) headers_received_callback_registered = true end end data_received_callbacks[req_handle] = data_received_callback or false if data_received_callback ~= nil then if not data_received_callback_registered then register_callback(CALLBACK_HTTPRequestDataReceived, http_request_data_received) data_received_callback_registered = true end end end local call_handle = SteamAPICall_t_arr() if not send_func(req_handle, call_handle) then native_ReleaseHTTPRequest(req_handle) if completed_callback ~= nil then completed_callback(false, {status = 0, status_message = "Failed to send request"}) end return end if options.priority == "defer" or options.priority == "prioritize" then local func = options.priority == "prioritize" and native_PrioritizeHTTPRequest or native_DeferHTTPRequest if not func(req_handle) then return http_request_error(req_handle, "failed to set priority") end elseif options.priority ~= nil then return http_request_error(req_handle, "options.priority has to be 'defer' of 'prioritize'") end completed_callbacks[req_handle] = completed_callback or false if completed_callback ~= nil then register_call_result(call_handle[0], http_request_completed, CALLBACK_HTTPRequestCompleted) end end local function cookie_container_new(allow_modification) if allow_modification ~= nil and type(allow_modification) ~= "boolean" then return error("allow_modification has to be of type boolean") end local handle_raw = native_CreateCookieContainer(allow_modification == true) if handle_raw ~= nil then local handle = CookieContainerHandle_t(handle_raw) ffi.gc(handle, cookie_container_gc) local key = setmetatable({}, cookie_container_mt) cookie_containers[key] = handle return key end end local M = { request = http_request_new, create_cookie_container = cookie_container_new } for method in pairs(method_name_to_enum) do M[method] = function(...) return http_request_new(method, ...) end end return M end)()
local json = {} local encode local escape_char_map = { [ "\\" ] = "\\", [ "\"" ] = "\"", [ "\b" ] = "b", [ "\f" ] = "f", [ "\n" ] = "n", [ "\r" ] = "r", [ "\t" ] = "t", } local escape_char_map_inv = { [ "/" ] = "/" } for k, v in pairs(escape_char_map) do escape_char_map_inv[v] = k end local function escape_char(c) return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte())) end local function encode_nil(val) return "null" end local function encode_table(val, stack) local res = {} stack = stack or {} if stack[val] then error("circular reference") end stack[val] = true if rawget(val, 1) ~= nil or next(val) == nil then local n = 0 for k in pairs(val) do if type(k) ~= "number" then error("invalid table: mixed or invalid key types") end n = n + 1 end if n ~= #val then error("invalid table: sparse array") end for i, v in ipairs(val) do table.insert(res, encode(v, stack)) end stack[val] = nil return "[" .. table.concat(res, ",") .. "]" else for k, v in pairs(val) do if type(k) ~= "string" then error("invalid table: mixed or invalid key types") end table.insert(res, encode(k, stack) .. ":" .. encode(v, stack)) end stack[val] = nil return "{" .. table.concat(res, ",") .. "}" end end local function encode_string(val) return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"' end local function encode_number(val) if val ~= val or val <= -math.huge or val >= math.huge then error("unexpected number value '" .. tostring(val) .. "'") end return string.format("%.14g", val) end local type_func_map = { [ "nil"     ] = encode_nil, [ "table"   ] = encode_table, [ "string"  ] = encode_string, [ "number"  ] = encode_number, [ "boolean" ] = tostring, } encode = function(val, stack) local t = type(val) local f = type_func_map[t] if f then return f(val, stack) end error("unexpected type '" .. t .. "'") end function json.encode(val) return ( encode(val) ) end local parse local function create_set(...) local res = {} for i = 1, select("#", ...) do res[ select(i, ...) ] = true end return res end local space_chars   = create_set(" ", "\t", "\r", "\n") local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",") local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u") local literals      = create_set("true", "false", "null") local literal_map = { [ "true"  ] = true, [ "false" ] = false, [ "null"  ] = nil, } local function next_char(str, idx, set, negate) for i = idx, #str do if set[str:sub(i, i)] ~= negate then return i end end return #str + 1 end local function decode_error(str, idx, msg) local line_count = 1 local col_count = 1 for i = 1, idx - 1 do col_count = col_count + 1 if str:sub(i, i) == "\n" then line_count = line_count + 1 col_count = 1 end end error( string.format("%s at line %d col %d", msg, line_count, col_count) ) end local function codepoint_to_utf8(n) local f = math.floor if n <= 0x7f then return string.char(n) elseif n <= 0x7ff then return string.char(f(n / 64) + 192, n % 64 + 128) elseif n <= 0xffff then return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128) elseif n <= 0x10ffff then return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128, f(n % 4096 / 64) + 128, n % 64 + 128) end error( string.format("invalid unicode codepoint '%x'", n) ) end local function parse_unicode_escape(s) local n1 = tonumber( s:sub(1, 4),  16 ) local n2 = tonumber( s:sub(7, 10), 16 ) if n2 then return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000) else return codepoint_to_utf8(n1) end end local function parse_string(str, i) local res = "" local j = i + 1 local k = j while j <= #str do local x = str:byte(j) if x < 32 then decode_error(str, j, "control character in string") elseif x == 92 then res = res .. str:sub(k, j - 1) j = j + 1 local c = str:sub(j, j) if c == "u" then local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1) or str:match("^%x%x%x%x", j + 1) or decode_error(str, j - 1, "invalid unicode escape in string") res = res .. parse_unicode_escape(hex) j = j + #hex else if not escape_chars[c] then decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string") end res = res .. escape_char_map_inv[c] end k = j + 1 elseif x == 34 then res = res .. str:sub(k, j - 1) return res, j + 1 end j = j + 1 end decode_error(str, i, "expected closing quote for string") end local function parse_number(str, i) local x = next_char(str, i, delim_chars) local s = str:sub(i, x - 1) local n = tonumber(s) if not n then decode_error(str, i, "invalid number '" .. s .. "'") end return n, x end local function parse_literal(str, i) local x = next_char(str, i, delim_chars) local word = str:sub(i, x - 1) if not literals[word] then decode_error(str, i, "invalid literal '" .. word .. "'") end return literal_map[word], x end local function parse_array(str, i) local res = {} local n = 1 i = i + 1 while 1 do local x i = next_char(str, i, space_chars, true) if str:sub(i, i) == "]" then i = i + 1 break end x, i = parse(str, i) res[n] = x n = n + 1 i = next_char(str, i, space_chars, true) local chr = str:sub(i, i) i = i + 1 if chr == "]" then break end if chr ~= "," then decode_error(str, i, "expected ']' or ','") end end return res, i end local function parse_object(str, i) local res = {} i = i + 1 while 1 do local key, val i = next_char(str, i, space_chars, true) if str:sub(i, i) == "}" then i = i + 1 break end if str:sub(i, i) ~= '"' then decode_error(str, i, "expected string for key") end key, i = parse(str, i) i = next_char(str, i, space_chars, true) if str:sub(i, i) ~= ":" then decode_error(str, i, "expected ':' after key") end i = next_char(str, i + 1, space_chars, true) val, i = parse(str, i) res[key] = val i = next_char(str, i, space_chars, true) local chr = str:sub(i, i) i = i + 1 if chr == "}" then break end if chr ~= "," then decode_error(str, i, "expected '}' or ','") end end return res, i end local char_func_map = { [ '"' ] = parse_string, [ "0" ] = parse_number, [ "1" ] = parse_number, [ "2" ] = parse_number, [ "3" ] = parse_number, [ "4" ] = parse_number, [ "5" ] = parse_number, [ "6" ] = parse_number, [ "7" ] = parse_number, [ "8" ] = parse_number, [ "9" ] = parse_number, [ "-" ] = parse_number, [ "t" ] = parse_literal, [ "f" ] = parse_literal, [ "n" ] = parse_literal, [ "[" ] = parse_array, [ "{" ] = parse_object, } parse = function(str, idx) local chr = str:sub(idx, idx) local f = char_func_map[chr] if f then return f(str, idx) end decode_error(str, idx, "unexpected character '" .. chr .. "'") end function json.parse(str) if type(str) ~= "string" then error("expected argument of type string, got " .. type(str)) end local res, idx = parse(str, next_char(str, 1, space_chars, true)) idx = next_char(str, idx, space_chars, true) if idx <= #str then decode_error(str, idx, "trailing garbage") end return res end
local panorama = (function() local _INFO, cast, typeof, new, find_pattern, create_interface, api, safe_mode, _error, exception, exceptionCb, rawgetImpl, rawsetImpl, __thiscall, table_copy, vtable_bind, interface_ptr, vtable_entry, vtable_thunk, proc_bind, follow_call, v8js_args, v8js_function, is_array, nullptr, intbuf, panorama, vtable, DllImport, UIEngine, nativeIsValidPanelPointer, nativeGetLastDispatchedEventTargetPanel, nativeCompileRunScript, nativeRunScript, nativeGetV8GlobalContext, nativeGetIsolate, nativeGetParent, nativeGetID, nativeFindChildTraverse, nativeGetJavaScriptContextParent, nativeGetPanelContext, jsContexts, getJavaScriptContextParent, v8_dll, persistentTbl, Local, MaybeLocal, PersistentProxy_mt, Persistent, Value, Object, Array, Function, ObjectTemplate, FunctionTemplate, FunctionCallbackInfo, Primitive, Null, Undefined, Boolean, Number, Integer, String, Isolate, Context, HandleScope, TryCatch, Script, PanelInfo_t, CUtlVector_Constructor_t, panelList, panelArrayOffset, panelArray _INFO = { _VERSION = 1.3 } setmetatable(_INFO, { __call = function(self) return self._VERSION end, __tostring = function(self) return self._VERSION end }) if _G and not ffi then ffi = require("ffi") end do local _obj_0 = ffi cast, typeof, new = _obj_0.cast, _obj_0.typeof, _obj_0.new end find_pattern = function() return error("Unsupported provider (e.g. gamesense, neverlose)") end create_interface = function() return error("Unsupported provider (e.g. gamesense, neverlose)") end api = (_G == nil) and (info.fatality == nil and "ev0lve" or "fa7ality") or (file == nil and (GameEventManager == nil and (penetration == nil and (math_utils == nil and "primordial" or "legion") or "pandora") or "memesense") or "legendware") local _exp_0 = api if "ev0lve" == _exp_0 then find_pattern = utils.find_pattern create_interface = utils.find_interface elseif "fa7ality" == _exp_0 then find_pattern = utils.find_pattern create_interface = utils.find_interface elseif "primordial" == _exp_0 then find_pattern = memory.find_pattern create_interface = memory.create_interface elseif "memesense" == _exp_0 then find_pattern = Utils.PatternScan create_interface = Utils.CreateInterface elseif "legendware" == _exp_0 then find_pattern = utils.find_signature create_interface = utils.create_interface elseif "pandora" == _exp_0 then find_pattern = client.find_sig create_interface = client.create_interface elseif "legion" == _exp_0 then find_pattern = memory.find_pattern create_interface = memory.create_interface end safe_mode = xpcall and true or false _error = error if 1 + 2 == 3 then error = function(msg) for _, v in pairs(persistentTbl) do Persistent(v):disposeGlobal() end return _error(msg) end end exception = function(msg) return print("Caught exception in V8 HandleScope: ", tostring(msg)) end exceptionCb = function(msg) return print("Caught exception in V8 Function Callback: ", tostring(msg)) end rawgetImpl = function(tbl, key) local mtb = getmetatable(tbl) setmetatable(tbl, nil) local res = tbl[key] setmetatable(tbl, mtb) return res end rawsetImpl = function(tbl, key, value) local mtb = getmetatable(tbl) setmetatable(tbl, nil) tbl[key] = value return setmetatable(tbl, mtb) end if not rawget then rawget = rawgetImpl end if not rawset then rawset = rawsetImpl end __thiscall = function(func, this) return function(...) return func(this, ...) end end table_copy = function(t) local _tbl_0 = { } for k, v in pairs(t) do _tbl_0[k] = v end return _tbl_0 end vtable_bind = function(module, interface, index, typedef) local addr = cast("void***", create_interface(module, interface)) or error(interface .. " is nil.") return __thiscall(cast(typedef, addr[0][index]), addr) end interface_ptr = typeof("void***") vtable_entry = function(instance, i, ct) return cast(ct, cast(interface_ptr, instance)[0][i]) end vtable_thunk = function(i, ct) local t = typeof(ct) return function(instance, ...) return vtable_entry(instance, i, t)(instance, ...) end end proc_bind = (function() local fnGetProcAddress fnGetProcAddress = function() return error("Failed to load GetProcAddress") end local fnGetModuleHandle fnGetModuleHandle = function() return error("Failed to load GetModuleHandleA") end if ffi.C then ffi.cdef([[            uint32_t GetProcAddress(uint32_t, const char*); uint32_t GetModuleHandleA(const char*); ]]) fnGetProcAddress = ffi.C.GetProcAddress fnGetModuleHandle = ffi.C.GetModuleHandleA else fnGetProcAddress = cast("uint32_t(__stdcall*)(uint32_t, const char*)", cast("uint32_t**", cast("uint32_t", find_pattern("engine.dll", "FF 15 ? ? ? ? A3 ? ? ? ? EB 05")) + 2)[0][0]) fnGetModuleHandle = cast("uint32_t(__stdcall*)(const char*)", cast("uint32_t**", cast("uint32_t", find_pattern("engine.dll", "FF 15 ? ? ? ? 85 C0 74 0B")) + 2)[0][0]) end return function(module_name, function_name, typedef) return cast(typeof(typedef), fnGetProcAddress(fnGetModuleHandle(module_name), function_name)) end end)() follow_call = function(ptr) local insn = cast("uint8_t*", ptr) local _exp_1 = insn[0] if (0xE8 or 0xE9) == _exp_1 then return cast("uint32_t", insn + cast("int32_t*", insn + 1)[0] + 5) elseif 0xFF == _exp_1 then if insn[1] == 0x15 then return cast("uint32_t**", cast("const char*", ptr) + 2)[0][0] end else return ptr end end v8js_args = function(...) local argTbl = { ... } local iArgc = #argTbl local pArgv = new(("void*[%.f]"):format(iArgc)) for i = 1, iArgc do pArgv[i - 1] = Value:fromLua(argTbl[i]):getInternal() end return iArgc, pArgv end v8js_function = function(callbackFunction) return function(callbackInfo) callbackInfo = FunctionCallbackInfo(callbackInfo) local argTbl = { } local length = callbackInfo:length() if length > 0 then for i = 0, length - 1 do table.insert(argTbl, callbackInfo:get(i)) end end local val = nil if safe_mode then local status, ret = xpcall((function() return callbackFunction(unpack(argTbl)) end), exceptionCb) if status then val = ret end else val = callbackFunction(unpack(argTbl)) end return callbackInfo:setReturnValue(Value:fromLua(val):getInternal()) end end is_array = function(val) local i = 1 for _ in pairs(val) do if val[i] ~= nil then i = i + 1 else return false end end return i ~= 1 end nullptr = new("void*") intbuf = new("int[1]") panorama = { panelIDs = { } } do local _class_0 local _base_0 = { get = function(self, index, t) return __thiscall(cast(t, self.this[0][index]), self.this) end, getInstance = function(self) return self.this end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, ptr) self.this = cast("void***", ptr) end, __base = _base_0, __name = "vtable" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 vtable = _class_0 end do local _class_0 local _base_0 = { cache = { }, get = function(self, method, typedef) if not (self.cache[method]) then self.cache[method] = proc_bind(self.file, method, typedef) end return self.cache[method] end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, filename) self.file = filename end, __base = _base_0, __name = "DllImport" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 DllImport = _class_0 end UIEngine = vtable(vtable_bind("panorama.dll", "PanoramaUIEngine001", 11, "void*(__thiscall*)(void*)")()) nativeIsValidPanelPointer = UIEngine:get(36, "bool(__thiscall*)(void*,void const*)") nativeGetLastDispatchedEventTargetPanel = UIEngine:get(56, "void*(__thiscall*)(void*)") nativeCompileRunScript = UIEngine:get(113, "void****(__thiscall*)(void*,void*,char const*,char const*,int,int,bool)") nativeRunScript = __thiscall(cast(typeof("void*(__thiscall*)(void*,void*,void*,void*,int,bool)"), follow_call(find_pattern("panorama.dll", api == "legendware" and "E8 ? ? ? ? 8B 4C 24 10 FF 15 ?" or "E8 ? ? ? ? 8B 4C 24 10 FF 15 ? ? ? ?"))), UIEngine:getInstance()) nativeGetV8GlobalContext = UIEngine:get(123, "void*(__thiscall*)(void*)") nativeGetIsolate = UIEngine:get(129, "void*(__thiscall*)(void*)") nativeGetParent = vtable_thunk(25, "void*(__thiscall*)(void*)") nativeGetID = vtable_thunk(9, "const char*(__thiscall*)(void*)") nativeFindChildTraverse = vtable_thunk(40, "void*(__thiscall*)(void*,const char*)") nativeGetJavaScriptContextParent = vtable_thunk(218, "void*(__thiscall*)(void*)") nativeGetPanelContext = __thiscall(cast("void***(__thiscall*)(void*,void*)", follow_call(find_pattern("panorama.dll", "E8 ? ? ? ? 8B 00 85 C0 75 1B"))), UIEngine:getInstance()) jsContexts = { } getJavaScriptContextParent = function(panel) if jsContexts[panel] ~= nil then return jsContexts[panel] end jsContexts[panel] = nativeGetJavaScriptContextParent(panel) return jsContexts[panel] end v8_dll = DllImport("v8.dll") persistentTbl = { } do local _class_0 local _base_0 = { getInternal = function(self) return self.this end, globalize = function(self) local pPersistent = v8_dll:get("?GlobalizeReference@V8@v8@@CAPAPAVObject@internal@2@PAVIsolate@42@PAPAV342@@Z", "void*(__cdecl*)(void*,void*)")(nativeGetIsolate(), self.this[0]) local persistent = Persistent(pPersistent) persistentTbl[persistent:getIdentityHash()] = pPersistent return persistent end, __call = function(self) return Value(self.this[0]) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void**", val) end, __base = _base_0, __name = "Local" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Local = _class_0 end do local _class_0 local _base_0 = { getInternal = function(self) return self.this end, toLocalChecked = function(self) if not (self.this[0] == nullptr) then return Local(self.this) end end, toValueChecked = function(self) if not (self.this[0] == nullptr) then return Value(self.this[0]) end end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void**", val) end, __base = _base_0, __name = "MaybeLocal" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 MaybeLocal = _class_0 end PersistentProxy_mt = { __index = function(self, key) local this = rawget(self, "this") local ret = HandleScope()(function() return this:getAsValue():toObject():get(Value:fromLua(key):getInternal()):toValueChecked():toLua() end) if type(ret) == "table" then rawset(ret, "parent", this) end return ret end, __newindex = function(self, key, value) local this = rawget(self, "this") return HandleScope()(function() return this:getAsValue():toObject():set(Value:fromLua(key):getInternal(), Value:fromLua(value):getInternal()):toValueChecked():toLua() end) end, __len = function(self) local this = rawget(self, "this") local ret = 0 if this.baseType == "Array" then ret = HandleScope()(function() return this:getAsValue():toArray():length() end) elseif this.baseType == "Object" then ret = HandleScope()(function() return this:getAsValue():toObject():getPropertyNames():toValueChecked():toArray():length() end) end return ret end, __pairs = function(self) local this = rawget(self, "this") local ret ret = function() return nil end if this.baseType == "Object" then HandleScope()(function() local keys = Array(this:getAsValue():toObject():getPropertyNames():toValueChecked()) local current, size = 0, keys:length() ret = function() current = current + 1 local key = keys[current - 1] if current <= size then return key, self[key] end end end) end return ret end, __ipairs = function(self) local this = rawget(self, "this") local ret ret = function() return nil end if this.baseType == "Array" then HandleScope()(function() local current, size = 0, this:getAsValue():toArray():length() ret = function() current = current + 1 if current <= size then return current, self[current - 1] end end end) end return ret end, __call = function(self, ...) local this = rawget(self, "this") local args = { ... } if this.baseType ~= "Function" then error("Attempted to call a non-function value: " .. this.baseType) end return HandleScope()(function() local rawReturn = this:getAsValue():toFunction():setParent(rawget(self, "parent"))(unpack(args)):toLocalChecked() if rawReturn == nil then return nil else return rawReturn():toLua() end end) end, __tostring = function(self) local this = rawget(self, "this") return HandleScope()(function() return this:getAsValue():stringValue() end) end, __gc = function(self) local this = rawget(self, "this") return this:disposeGlobal() end } do local _class_0 local _base_0 = { setType = function(self, val) self.baseType = val return self end, getInternal = function(self) return self.this end, disposeGlobal = function(self) return v8_dll:get("?DisposeGlobal@V8@v8@@CAXPAPAVObject@internal@2@@Z", "void(__cdecl*)(void*)")(self.this) end, get = function(self) return MaybeLocal(HandleScope:createHandle(self.this)) end, getAsValue = function(self) return Value(HandleScope:createHandle(self.this)[0]) end, toLua = function(self) return self:get():toValueChecked():toLua() end, getIdentityHash = function(self) return v8_dll:get("?GetIdentityHash@Object@v8@@QAEHXZ", "int(__thiscall*)(void*)")(self.this) end, __call = function(self) return setmetatable({ this = self, parent = nil }, PersistentProxy_mt) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val, baseType) if baseType == nil then baseType = "Value" end self.this = val self.baseType = baseType end, __base = _base_0, __name = "Persistent" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Persistent = _class_0 end do local _class_0 local _base_0 = { fromLua = function(self, val) if val == nil then return Null(nativeGetIsolate()):getValue() end local valType = type(val) local _exp_1 = valType if "boolean" == _exp_1 then return Boolean(nativeGetIsolate(), val):getValue() elseif "number" == _exp_1 then return Number(nativeGetIsolate(), val):getInstance() elseif "string" == _exp_1 then return String(nativeGetIsolate(), val):getInstance() elseif "table" == _exp_1 then if is_array(val) then return Array:fromLua(nativeGetIsolate(), val) else return Object:fromLua(nativeGetIsolate(), val) end elseif "function" == _exp_1 then return FunctionTemplate(v8js_function(val)):getFunction()() else return error("Failed to convert from lua to v8js: Unknown type") end end, isUndefined = function(self) return v8_dll:get("?IsUndefined@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isNull = function(self) return v8_dll:get("?IsNull@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isBoolean = function(self) return v8_dll:get("?IsBoolean@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isBooleanObject = function(self) return v8_dll:get("?IsBooleanObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isNumber = function(self) return v8_dll:get("?IsNumber@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isNumberObject = function(self) return v8_dll:get("?IsNumberObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isString = function(self) return v8_dll:get("?IsString@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isStringObject = function(self) return v8_dll:get("?IsStringObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isObject = function(self) return v8_dll:get("?IsObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isArray = function(self) return v8_dll:get("?IsArray@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isFunction = function(self) return v8_dll:get("?IsFunction@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, booleanValue = function(self) return v8_dll:get("?BooleanValue@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, numberValue = function(self) return v8_dll:get("?NumberValue@Value@v8@@QBENXZ", "double(__thiscall*)(void*)")(self.this) end, stringValue = function(self) local strBuf = new('char*[2]') local val = v8_dll:get("??0Utf8Value@String@v8@@QAE@V?$Local@VValue@v8@@@2@@Z", "struct{char* str; int length;}*(__thiscall*)(void*,void*)")(strBuf, self.this) local s = ffi.string(val.str, val.length) v8_dll:get("??1Utf8Value@String@v8@@QAE@XZ", "void(__thiscall*)(void*)")(strBuf) return s end, toObject = function(self) return Object(MaybeLocal(v8_dll:get("?ToObject@Value@v8@@QBE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal()) end, toArray = function(self) return Array(MaybeLocal(v8_dll:get("?ToObject@Value@v8@@QBE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal()) end, toFunction = function(self) return Function(MaybeLocal(v8_dll:get("?ToObject@Value@v8@@QBE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal()) end, toLocal = function(self) return Local(new("void*[1]", self.this)) end, toLua = function(self) if self:isUndefined() or self:isNull() then return nil end if self:isBoolean() or self:isBooleanObject() then return self:booleanValue() end if self:isNumber() or self:isNumberObject() then return self:numberValue() end if self:isString() or self:isStringObject() then return self:stringValue() end if self:isObject() then if self:isArray() then return self:toArray():toLocal():globalize():setType("Array")() end if self:isFunction() then return self:toFunction():toLocal():globalize():setType("Function")() end return self:toObject():toLocal():globalize():setType("Object")() end return error("Failed to convert from v8js to lua: Unknown type") end, getInternal = function(self) return self.this end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void*", val) end, __base = _base_0, __name = "Value" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Value = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { fromLua = function(self, isolate, val) local obj = Object(MaybeLocal(v8_dll:get("?New@Object@v8@@SA?AV?$Local@VObject@v8@@@2@PAVIsolate@2@@Z", "void*(__cdecl*)(void*,void*)")(intbuf, isolate)):toValueChecked():getInternal()) for i, v in pairs(val) do obj:set(Value:fromLua(i):getInternal(), Value:fromLua(v):getInternal()) end return obj end, get = function(self, key) return MaybeLocal(v8_dll:get("?Get@Object@v8@@QAE?AV?$Local@VValue@v8@@@2@V32@@Z", "void*(__thiscall*)(void*,void*,void*)")(self.this, intbuf, key)) end, set = function(self, key, value) return v8_dll:get("?Set@Object@v8@@QAE_NV?$Local@VValue@v8@@@2@0@Z", "bool(__thiscall*)(void*,void*,void*)")(self.this, key, value) end, getPropertyNames = function(self) return MaybeLocal(v8_dll:get("?GetPropertyNames@Object@v8@@QAE?AV?$Local@VArray@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)) end, callAsFunction = function(self, recv, argc, argv) return MaybeLocal(v8_dll:get("?CallAsFunction@Object@v8@@QAE?AV?$Local@VValue@v8@@@2@V32@HQAV32@@Z", "void*(__thiscall*)(void*,void*,void*,int,void*)")(self.this, intbuf, recv, argc, argv)) end, getIdentityHash = function(self) return v8_dll:get("?GetIdentityHash@Object@v8@@QAEHXZ", "int(__thiscall*)(void*)")(self.this) end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Object", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Object = _class_0 end do local _class_0 local _parent_0 = Object local _base_0 = { fromLua = function(self, isolate, val) local arr = Array(MaybeLocal(v8_dll:get("?New@Array@v8@@SA?AV?$Local@VArray@v8@@@2@PAVIsolate@2@H@Z", "void*(__cdecl*)(void*,void*,int)")(intbuf, isolate, #val)):toValueChecked():getInternal()) for i = 1, #val do arr:set(i - 1, Value:fromLua(val[i]):getInternal()) end return arr end, get = function(self, key) return MaybeLocal(v8_dll:get("?Get@Object@v8@@QAE?AV?$Local@VValue@v8@@@2@I@Z", "void*(__thiscall*)(void*,void*,unsigned int)")(self.this, intbuf, key)) end, set = function(self, key, value) return v8_dll:get("?Set@Object@v8@@QAE_NIV?$Local@VValue@v8@@@2@@Z", "bool(__thiscall*)(void*,unsigned int,void*)")(self.this, key, value) end, length = function(self) return v8_dll:get("?Length@Array@v8@@QBEIXZ", "uint32_t(__thiscall*)(void*)")(self.this) end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Array", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Array = _class_0 end do local _class_0 local _parent_0 = Object local _base_0 = { setParent = function(self, val) self.parent = val return self end, __call = function(self, ...) if self.parent == nil then return self:callAsFunction(Context(Isolate(nativeGetIsolate()):getCurrentContext()):global():toValueChecked():getInternal(), v8js_args(...)) else return self:callAsFunction(self.parent:getAsValue():getInternal(), v8js_args(...)) end end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val, parent) self.this = val self.parent = parent end, __base = _base_0, __name = "Function", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Function = _class_0 end do local _class_0 local _base_0 = { } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self) self.this = MaybeLocal(v8_dll:get("?New@ObjectTemplate@v8@@SA?AV?$Local@VObjectTemplate@v8@@@2@XZ", "void*(__cdecl*)(void*)")(intbuf)):toLocalChecked() end, __base = _base_0, __name = "ObjectTemplate" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 ObjectTemplate = _class_0 end do local _class_0 local _base_0 = { getFunction = function(self) return MaybeLocal(v8_dll:get("?GetFunction@FunctionTemplate@v8@@QAE?AV?$Local@VFunction@v8@@@2@XZ", "void*(__thiscall*)(void*, void*)")(self:this():getInternal(), intbuf)):toLocalChecked() end, getInstance = function(self) return self:this() end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, callback) self.this = MaybeLocal(v8_dll:get("?New@FunctionTemplate@v8@@SA?AV?$Local@VFunctionTemplate@v8@@@2@PAVIsolate@2@P6AXABV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@V?$Local@VSignature@v8@@@2@HW4ConstructorBehavior@2@@Z", "void*(__cdecl*)(void*,void*,void*,void*,void*,int,int)")(intbuf, nativeGetIsolate(), cast("void(__cdecl*)(void******)", callback), new("int[1]"), new("int[1]"), 0, 0)):toLocalChecked() end, __base = _base_0, __name = "FunctionTemplate" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 FunctionTemplate = _class_0 end do local _class_0 local _base_0 = { kHolderIndex = 0, kIsolateIndex = 1, kReturnValueDefaultValueIndex = 2, kReturnValueIndex = 3, kDataIndex = 4, kCalleeIndex = 5, kContextSaveIndex = 6, kNewTargetIndex = 7, getHolder = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kHolderIndex]):toLocalChecked() end, getIsolate = function(self) return Isolate(self:getImplicitArgs_()[self.kIsolateIndex][0]) end, getReturnValueDefaultValue = function(self) return Value(new("void*[1]", self:getImplicitArgs_()[self.kReturnValueDefaultValueIndex])) end, getReturnValue = function(self) return Value(new("void*[1]", self:getImplicitArgs_()[self.kReturnValueIndex])) end, setReturnValue = function(self, value) self:getImplicitArgs_()[self.kReturnValueIndex] = cast("void**", value)[0] end, getData = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kDataIndex]):toLocalChecked() end, getCallee = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kCalleeIndex]):toLocalChecked() end, getContextSave = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kContextSaveIndex]):toLocalChecked() end, getNewTarget = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kNewTargetIndex]):toLocalChecked() end, getImplicitArgs_ = function(self) return self.this[0] end, getValues_ = function(self) return self.this[1] end, getLength_ = function(self) return self.this[2] end, length = function(self) return tonumber(cast("int", self:getLength_())) end, get = function(self, i) if self:length() > i then return Value(self:getValues_() - i):toLua() else return end end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void****", val) end, __base = _base_0, __name = "FunctionCallbackInfo" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 FunctionCallbackInfo = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { getValue = function(self) return self.this end, toString = function(self) return self.this:getValue():stringValue() end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Primitive", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Primitive = _class_0 end do local _class_0 local _parent_0 = Primitive local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate) self.this = Value(cast("uintptr_t", isolate) + 0x48) end, __base = _base_0, __name = "Null", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Null = _class_0 end do local _class_0 local _parent_0 = Primitive local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate) self.this = Value(cast("uintptr_t", isolate) + 0x56) end, __base = _base_0, __name = "Undefined", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Undefined = _class_0 end do local _class_0 local _parent_0 = Primitive local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, bool) self.this = Value(cast("uintptr_t", isolate) + ((function() if bool then return 0x4C else return 0x50 end end)())) end, __base = _base_0, __name = "Boolean", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Boolean = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { getLocal = function(self) return self.this end, getValue = function(self) return self:getInstance():numberValue() end, getInstance = function(self) return self:this() end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, val) self.this = MaybeLocal(v8_dll:get("?New@Number@v8@@SA?AV?$Local@VNumber@v8@@@2@PAVIsolate@2@N@Z", "void*(__cdecl*)(void*,void*,double)")(intbuf, isolate, tonumber(val))):toLocalChecked() end, __base = _base_0, __name = "Number", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Number = _class_0 end do local _class_0 local _parent_0 = Number local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, val) self.this = MaybeLocal(v8_dll:get("?NewFromUnsigned@Integer@v8@@SA?AV?$Local@VInteger@v8@@@2@PAVIsolate@2@I@Z", "void*(__cdecl*)(void*,void*,uint32_t)")(intbuf, isolate, tonumber(val))):toLocalChecked() end, __base = _base_0, __name = "Integer", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Integer = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { getLocal = function(self) return self.this end, getValue = function(self) return self:getInstance():stringValue() end, getInstance = function(self) return self:this() end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, val) self.this = MaybeLocal(v8_dll:get("?NewFromUtf8@String@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@PAVIsolate@2@PBDW4NewStringType@2@H@Z", "void*(__cdecl*)(void*,void*,const char*,int,int)")(intbuf, isolate, val, 0, #val)):toLocalChecked() end, __base = _base_0, __name = "String", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end String = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("?Enter@Isolate@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, exit = function(self) return v8_dll:get("?Exit@Isolate@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, getCurrentContext = function(self) return MaybeLocal(v8_dll:get("?GetCurrentContext@Isolate@v8@@QAE?AV?$Local@VContext@v8@@@2@XZ", "void**(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal() end, getInternal = function(self) return self.this end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) if val == nil then val = nativeGetIsolate() end self.this = val end, __base = _base_0, __name = "Isolate" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Isolate = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("?Enter@Context@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, exit = function(self) return v8_dll:get("?Exit@Context@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, global = function(self) return MaybeLocal(v8_dll:get("?Global@Context@v8@@QAE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Context" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Context = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("??0HandleScope@v8@@QAE@PAVIsolate@1@@Z", "void(__thiscall*)(void*,void*)")(self.this, nativeGetIsolate()) end, exit = function(self) return v8_dll:get("??1HandleScope@v8@@QAE@XZ", "void(__thiscall*)(void*)")(self.this) end, createHandle = function(self, val) return v8_dll:get("?CreateHandle@HandleScope@v8@@KAPAPAVObject@internal@2@PAVIsolate@42@PAV342@@Z", "void**(__cdecl*)(void*,void*)")(nativeGetIsolate(), val) end, __call = function(self, func, panel) if panel == nil then panel = panorama.GetPanel("CSGOJsRegistration") end local isolate = Isolate() isolate:enter() self:enter() local ctx if panel then ctx = nativeGetPanelContext(getJavaScriptContextParent(panel))[0] else ctx = Context(isolate:getCurrentContext()):global():getInternal() end ctx = Context((function() if ctx ~= nullptr then return self:createHandle(ctx[0]) else return 0 end end)()) ctx:enter() local val = nil if safe_mode then local status, ret = xpcall(func, exception) if status then val = ret end else val = func() end ctx:exit() self:exit() isolate:exit() return val end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self) self.this = new("char[0xC]") end, __base = _base_0, __name = "HandleScope" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 HandleScope = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("??0TryCatch@v8@@QAE@PAVIsolate@1@@Z", "void(__thiscall*)(void*,void*)")(self.this, nativeGetIsolate()) end, exit = function(self) return v8_dll:get("??1TryCatch@v8@@QAE@XZ", "void(__thiscall*)(void*)")(self.this) end, canContinue = function(self) return v8_dll:get("?CanContinue@TryCatch@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, hasTerminated = function(self) return v8_dll:get("?HasTerminated@TryCatch@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, hasCaught = function(self) return v8_dll:get("?HasCaught@TryCatch@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self) self.this = new("char[0x19]") end, __base = _base_0, __name = "TryCatch" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 TryCatch = _class_0 end do local _class_0 local _base_0 = { compile = function(self, panel, source, layout) if layout == nil then layout = "" end return __thiscall(cast("void**(__thiscall*)(void*,void*,const char*,const char*)", api == "memesense" and find_pattern("panorama.dll", "E8 ? ? ? ? 8B 4C 24 10 FF 15 ? ? ? ?") - 2816 or find_pattern("panorama.dll", "55 8B EC 83 E4 F8 83 EC 64 53 8B D9")), UIEngine:getInstance())(panel, source, layout) end, loadstring = function(self, str, panel) local isolate = Isolate(nativeGetIsolate()) local handleScope = HandleScope() local tryCatch = TryCatch() isolate:enter() handleScope:enter() local ctx if panel then ctx = nativeGetPanelContext(getJavaScriptContextParent(panel))[0] else ctx = Context(isolate:getCurrentContext()):global():getInternal() end ctx = Context((function() if ctx ~= nullptr then return handleScope:createHandle(ctx[0]) else return 0 end end)()) ctx:enter() tryCatch:enter() local compiled = MaybeLocal(self:compile(panel, str)):toLocalChecked() tryCatch:exit() local ret if not (compiled == nil) then ret = MaybeLocal(nativeRunScript(intbuf, panel, compiled():getInternal(), 0, false)):toValueChecked():toLua() end if not (((not safe_mode) or ret)) then ret = (function() return print("WARNING: Attempted to call nullptr") end) end ctx:exit() handleScope:exit() isolate:exit() return ret end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function() end, __base = _base_0, __name = "Script" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Script = _class_0 end PanelInfo_t = typeof([[    struct { char* pad1[0x4]; void*         m_pPanel; void* unk1; } ]]) CUtlVector_Constructor_t = typeof([[    struct { struct { $ *m_pMemory; int m_nAllocationCount; int m_nGrowSize; } m_Memory; int m_Size; $ *m_pElements; } ]], PanelInfo_t, PanelInfo_t) ffi.metatype(CUtlVector_Constructor_t, { __index = { Count = function(self) return self.m_Memory.m_nAllocationCount end, Element = function(self, i) return cast(typeof("$&", PanelInfo_t), self.m_Memory.m_pMemory[i]) end, RemoveAll = function(self) self = nil self = typeof("$[?]", CUtlVector_Constructor_t)(1)[0] self.m_Size = 0 end }, __ipairs = function(self) local current, size = 0, self:Count() return function() current = current + 1 local pPanel = self:Element(current - 1).m_pPanel if current <= size and nativeIsValidPanelPointer(pPanel) then return current, pPanel end end end }) panelList = typeof("$[?]", CUtlVector_Constructor_t)(1)[0] panelArrayOffset = cast("unsigned int*", cast("uintptr_t**", UIEngine:getInstance())[0][36] + 21)[0] panelArray = cast(panelList, cast("uintptr_t", UIEngine:getInstance()) + panelArrayOffset) panorama.hasPanel = function(panelName) for i, v in ipairs(panelArray) do local curPanelName = ffi.string(nativeGetID(v)) if curPanelName == panelName then return true end end return false end panorama.getPanel = function(panelName, fallback) local cachedPanel = panorama.panelIDs[panelName] if cachedPanel ~= nil and nativeIsValidPanelPointer(cachedPanel) and ffi.string(nativeGetID(cachedPanel)) == panelName then return cachedPanel end panorama.panelIDs = { } local pPanel = nullptr for i, v in ipairs(panelArray) do local curPanelName = ffi.string(nativeGetID(v)) if curPanelName ~= "" then panorama.panelIDs[curPanelName] = v if curPanelName == panelName then pPanel = v break end end end if pPanel == nullptr then if fallback ~= nil then pPanel = panorama.getPanel(fallback) else error(("Failed to get target panel %s (EAX == 0)"):format(tostring(panelName))) end end return pPanel end panorama.runScript = function(jsCode, panel, pathToXMLContext) if panel == nil then panel = panorama.getPanel("CSGOJsRegistration") end if pathToXMLContext == nil then pathToXMLContext = "panorama/layout/base.xml" end if not nativeIsValidPanelPointer(panel) then error("Invalid panel pointer (EAX == 0)") end return nativeCompileRunScript(panel, jsCode, pathToXMLContext, 8, 10, false) end panorama.loadstring = function(jsCode, panel) if panel == nil then panel = "CSGOJsRegistration" end local fallback = "CSGOJsRegistration" if panel == "CSGOMainMenu" then fallback = "CSGOHub" end if panel == "CSGOHub" then fallback = "CSGOMainMenu" end return Script:loadstring(("(()=>{%s})"):format(jsCode), panorama.getPanel(panel, fallback)) end panorama.open = function(panel) if panel == nil then panel = "CSGOJsRegistration" end local fallback = "CSGOJsRegistration" if panel == "CSGOMainMenu" then fallback = "CSGOHub" end if panel == "CSGOHub" then fallback = "CSGOMainMenu" end return HandleScope()(function() return Context(Isolate():getCurrentContext()):global():toValueChecked():toLua(), panorama.GetPanel(panel, fallback) end) end panorama.GetPanel = panorama.getPanel panorama.RunScript = panorama.runScript panorama.panelArray = panelArray panorama.info = _INFO setmetatable(panorama, { __tostring = function(self) return ("luv8 panorama library v%.1f"):format(_INFO._VERSION) end, __index = function(self, key) if panorama.hasPanel(key) then return panorama.open(key) end return panorama.open()[key] end }) return panorama end)()
local SteamOverlayAPI = panorama.open().SteamOverlayAPI

function update_list(element, item)
    if type(item) == 'table' then
        local items = element:get_items()
        for i = 1, #items do
            element:remove_item(items[i])
        end
        
        for i = 1, #item do
            if item[i] ~= nil then
                element:add_item(item[i])
            end
        end
    end
end

local cheat = menu.add_selection("uidpolice {test version}", "Cheat", {"neverlose", "primordial", "fatality", "monolith", "pandora", "nemesis"})
local uid_or_name = menu.add_text_input("uidpolice {test version}", "UID/Name")

local list = menu.add_list("Result", "", {"Uid: ", "Username: ", "Inviter: ", "Joined: ", "Ban: "})

local rename_list = {"neverlose", "primordial", "fatality", "monolith", "pandora", "nemesis"}

local avatar = ""
menu.add_button("uidpolice {test version}", "Get Result", function()
    http1.get("https://uidpolice.xyz/api/" .. rename_list[cheat:get()] .. "/" .. uid_or_name:get(), function(success, response)
        if success and response.status == 200 then
            local table_web = json.parse(response.body)
            if table_web["uid"] == nil then 
                table_web["uid"] = "no user"
                table_web["username"] = "no user"
                table_web["joined"] = "no user"
                table_web["banned"] = "no user"
                table_web["avatar"] = "https://avatars.cloudflare.steamstatic.com/fef49e7fa7e1997310d705b2a6158ff8dc1cdfeb_medium.jpg"
            end
            if table_web["inviter"] == nil then
                table_web["inviter"] = "no inviter"
            end
            --list:update({"Uid: " .. table_web["uid"], "Username: " .. table_web["username"], "Inviter: " .. table_web["inviter"], "Joined: " .. table_web["joined"], "Ban: " .. tostring(table_web["banned"])})
            update_list(list, {"Uid: " .. table_web["uid"], "Username: " .. table_web["username"], "Inviter: " .. table_web["inviter"], "Joined: " .. table_web["joined"], "Ban: " .. tostring(table_web["banned"])})
            avatar = table_web["avatar"]
        end
    end)
end)

menu.add_button("Result", "Avatar", function()
    SteamOverlayAPI.OpenExternalBrowserURL(avatar)
end)

menu.add_button("Information", "Telegram", function()
    SteamOverlayAPI.OpenExternalBrowserURL("http://t.me/uidpolicexyz")
end)

menu.add_button("Information", "Telegram Bot", function()
    SteamOverlayAPI.OpenExternalBrowserURL("http://t.me/uidpolicebot")
end)

menu.add_button("Information", "Website", function()
    SteamOverlayAPI.OpenExternalBrowserURL("https://uidpolice.xyz")
end)